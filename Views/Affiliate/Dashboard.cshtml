@{
  ViewData["Title"] = "Affiliate Dashboard";
  Layout = "_ContentNavbarLayout";
}

@section PageStyles {
  <link rel="stylesheet" href="~/vendor/css/pages/page-auth.css">
  <style>
    .loading {
      opacity: 0.6;
    }
  </style>
}

<div class="container-xxl flex-grow-1 container-p-y">
  <h4 class="fw-bold py-3 mb-4">
    <span class="text-muted fw-light">Affiliate /</span> Dashboard
  </h4>

  <div id="dashboard-content">
    <!-- Stats Cards Row -->
    <div class="row mb-4">
      <div class="col-md-3">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">Total Earnings</h5>
            <h2 id="total-earnings" class="display-6">$0</h2>
          </div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">Paid Earnings</h5>
            <h2 id="paid-earnings" class="display-6">$0</h2>
          </div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">Pending Payments</h5>
            <h2 id="unpaid-earnings" class="display-6">$0</h2>
          </div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card">
          <div class="card-body">
            <h5 class="card-title">Customers</h5>
            <h2 id="customer-count" class="display-6">0</h2>
          </div>
        </div>
      </div>
    </div>

    <!-- Chart Row -->
    <div class="row mb-4">
      <div class="col-12">
        <div class="card">
          <div class="card-header">
            <h5 class="card-title">Monthly Earnings</h5>
          </div>
          <div class="card-body">
            <canvas id="earnings-chart" height="100"></canvas>
          </div>
        </div>
      </div>
    </div>

    <!-- Tables Row -->
    <div class="row">
      <!-- Recent Commissions -->
      <div class="col-md-6 mb-4">
        <div class="card h-100">
          <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="card-title">Recent Commissions</h5>
            <a href="/Affiliate/Commissions" class="btn btn-sm btn-primary">View All</a>
          </div>
          <div class="card-body">
            <div class="table-responsive">
              <table id="recent-commissions" class="table table-hover">
                <thead>
                  <tr>
                    <th>Order ID</th>
                    <th>Customer</th>
                    <th>Amount</th>
                    <th>Status</th>
                    <th>Date</th>
                  </tr>
                </thead>
                <tbody>
                  <!-- Will be populated by JS -->
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <!-- Recent Customers -->
      <div class="col-md-6 mb-4">
        <div class="card h-100">
          <div class="card-header d-flex justify-content-between align-items-center">
            <h5 class="card-title">Recent Customers</h5>
            <a href="/Affiliate/Customers" class="btn btn-sm btn-primary">View All</a>
          </div>
          <div class="card-body">
            <div class="table-responsive">
              <table id="recent-customers" class="table table-hover">
                <thead>
                  <tr>
                    <th>ID</th>
                    <th>Name</th>
                    <th>Email</th>
                  </tr>
                </thead>
                <tbody>
                  <!-- Will be populated by JS -->
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

@section PageScripts {
  <!-- Firebase Libraries -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- SweetAlert -->
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

  <script src="~/js/firebase-init.js"></script>

  <script>
    // Firebase service
    const firebaseService = {
      // Initialize Firebase
      init: function (config) {
        if (!firebase.apps.length) {
          firebase.initializeApp(config);
        }
        this.db = firebase.firestore();
        return this;
      },

      // Authentication
      getCurrentUser: function () {
        return firebase.auth().currentUser;
      },

      // Affiliate Methods
      getAffiliateByUserId: async function (userId) {
        try {
          console.log("Looking for affiliate with userId:", userId);

          // First try the dedicated affiliates collection
          let snapshot = await this.db.collection('affiliates')
            .where('UserId', '==', userId)
            .limit(1)
            .get();

          // If not found, check the users collection with Role == '2' (affiliate)
          if (snapshot.empty) {
            console.log("Not found in affiliates collection, checking users collection");

            snapshot = await this.db.collection('users')
              .where('Role', '==', '2') // Role 2 for affiliates
              .where(firebase.firestore.FieldPath.documentId(), '==', userId)
              .limit(1)
              .get();

            // If still not found, try directly getting the user document by ID
            if (snapshot.empty) {
              console.log("Not found by role query, trying direct document lookup");

              try {
                const userDoc = await this.db.collection('users')
                  .doc(userId)
                  .get();

                if (userDoc.exists) {
                  const userData = userDoc.data();
                  console.log("Found user document:", userData);

                  if (userData.Role === '2') {
                    return { affiliateId: userDoc.id, ...userData };
                  }
                }
              } catch (directLookupError) {
                console.warn("Direct document lookup error:", directLookupError);
              }
            }
          }

          if (snapshot.empty) {
            console.log("No affiliate record found, trying userId as affiliateId directly");
            // As a last resort, assume the userId itself is the affiliateId
            return { affiliateId: userId };
          }

          const doc = snapshot.docs[0];
          console.log("Found affiliate record:", doc.data());
          return { affiliateId: doc.id, ...doc.data() };
        } catch (error) {
          console.error('Error getting affiliate:', error);
          return null;
        }
      },

      getCommissionsByAffiliateId: async function (affiliateId) {
        try {
          console.log("Getting commissions for affiliateId:", affiliateId);

          // Try multiple field names for affiliate ID reference
          const possibleAffiliateFields = ['AffiliateId', 'affiliateId', 'ReferenceId', 'referenceId', 'UserId'];
          let allCommissions = [];

          // Try with "commissions" collection
          try {
            console.log("Querying commissions collection");
            // Try each possible field name
            for (const field of possibleAffiliateFields) {
              console.log(`Trying field: ${field}`);
              try {
                const snapshot = await this.db.collection('commissions')
                  .where(field, '==', affiliateId)
                  .limit(50) // Limit to 50 for performance
                  .get();

                if (!snapshot.empty) {
                  console.log(`Found commissions with field ${field}, count:`, snapshot.size);
                  allCommissions = snapshot.docs.map(doc => ({ commissionId: doc.id, ...doc.data() }));
                  break;
                }
              } catch (fieldError) {
                console.warn(`Error querying with field ${field}:`, fieldError);
              }
            }
          } catch (error) {
            console.warn('Error with commissions collection:', error);
          }

          // If nothing found, try with alternative collection name
          if (allCommissions.length === 0) {
            console.log("No commissions found, trying alternative collection name");
            try {
              for (const field of possibleAffiliateFields) {
                try {
                  const snapshot = await this.db.collection('commisiond') // Alternative spelling
                    .where(field, '==', affiliateId)
                    .limit(50) // Limit to 50 for performance
                    .get();

                  if (!snapshot.empty) {
                    console.log(`Found commissions in alternative collection with field ${field}, count:`, snapshot.size);
                    allCommissions = snapshot.docs.map(doc => ({ commissionId: doc.id, ...doc.data() }));
                    break;
                  }
                } catch (fieldError) {
                  console.warn(`Error querying alternative collection with field ${field}:`, fieldError);
                }
              }
            } catch (altError) {
              console.warn('Error with alternative commissions collection:', altError);
            }
          }

          // Sort by date if possible
          if (allCommissions.length > 0) {
            console.log("Total commissions found:", allCommissions.length);
            allCommissions.sort((a, b) => {
              // Try various date field names
              const dateFields = ['CreatedAt', 'createdAt', 'Date', 'date', 'OrderDate'];

              for (const field of dateFields) {
                if (a[field] && b[field]) {
                  // Handle Firestore timestamps
                  const dateA = a[field].toDate ? a[field].toDate() : new Date(a[field]);
                  const dateB = b[field].toDate ? b[field].toDate() : new Date(b[field]);
                  return dateB - dateA; // Newest first
                }
              }
              return 0;
            });
          } else {
            console.log("No commissions found for this affiliate");
          }

          return allCommissions;
        } catch (error) {
          console.error('Error getting commissions:', error);
          return [];
        }
      },

      getCustomersByAffiliateId: async function (affiliateId) {
        try {
          console.log("Getting customers for affiliateId:", affiliateId);

          // Try multiple field names for affiliate ID reference
          const possibleAffiliateFields = ['AffiliateId', 'affiliateId', 'ReferenceId', 'referenceId', 'RefererId'];
          let allCustomers = [];

          // Try first with dedicated customers collection
          try {
            console.log("Querying customers collection");
            // Try each possible field name
            for (const field of possibleAffiliateFields) {
              console.log(`Trying field: ${field}`);
              try {
                const snapshot = await this.db.collection('customers')
                  .where(field, '==', affiliateId)
                  .limit(50) // Limit to 50 for performance
                  .get();

                if (!snapshot.empty) {
                  console.log(`Found customers with field ${field}, count:`, snapshot.size);
                  allCustomers = snapshot.docs.map(doc => ({ customerId: doc.id, ...doc.data() }));
                  break;
                }
              } catch (fieldError) {
                console.warn(`Error querying with field ${field}:`, fieldError);
              }
            }
          } catch (error) {
            console.warn('Error with customers collection:', error);
          }

          // If no results, check users collection
          if (allCustomers.length === 0) {
            console.log("No customers found, checking users collection");
            try {
              for (const field of possibleAffiliateFields) {
                try {
                  const snapshot = await this.db.collection('users')
                    .where('Role', '==', '3') // Role 3 for customers
                    .where(field, '==', affiliateId)
                    .limit(50) // Limit to 50 for performance
                    .get();

                  if (!snapshot.empty) {
                    console.log(`Found customers in users collection with field ${field}, count:`, snapshot.size);
                    allCustomers = snapshot.docs.map(doc => ({ customerId: doc.id, ...doc.data() }));
                    break;
                  }
                } catch (fieldError) {
                  console.warn(`Error querying users collection with field ${field}:`, fieldError);
                }
              }
            } catch (error) {
              console.warn('Error with users collection:', error);
            }
          }

          console.log("Total customers found:", allCustomers.length);
          return allCustomers;
        } catch (error) {
          console.error('Error getting customers:', error);
          return [];
        }
      },

      getTotalCommission: function (commissions) {
        if (!commissions || !commissions.length) return 0;

        return commissions.reduce((sum, commission) => {
          // Try different field names
          const amount = commission.Amount || commission.amount || commission.Value || commission.value || 0;
          return sum + parseFloat(amount || 0);
        }, 0);
      },

      getUnpaidCommission: function (commissions) {
        if (!commissions || !commissions.length) return 0;

        console.log("Calculating unpaid commissions from:", commissions);

        // Filter commissions that are not paid
        const unpaidCommissions = commissions.filter(commission => {
          // Check various field names for payment status
          const isPaid = commission.IsPaid || commission.isPaid || commission.Paid || commission.paid || false;
          console.log(`Commission ${commission.commissionId || 'unknown'}: IsPaid=${isPaid}`);
          return isPaid === false; // Make sure we're explicitly checking for false
        });

        console.log(`Found ${unpaidCommissions.length} unpaid commissions`);

        // Sum up the amounts
        return unpaidCommissions.reduce((sum, commission) => {
          const amount = commission.Amount || commission.amount || commission.Value || commission.value || 0;
          return sum + parseFloat(amount || 0);
        }, 0);
      },

      getCommissionsByMonth: function (commissions) {
        const monthlyCommissions = {};

        if (!commissions || !commissions.length) return monthlyCommissions;

        commissions.forEach(commission => {
          // Try different date fields
          let date;
          const dateFields = ['CreatedAt', 'createdAt', 'Date', 'date', 'OrderDate', 'orderDate'];

          for (const field of dateFields) {
            if (commission[field]) {
              // Handle Firestore Timestamp
              date = commission[field].toDate ? commission[field].toDate() : new Date(commission[field]);
              break;
            }
          }

          if (!date) {
            console.warn("Commission missing date field:", commission);
            return; // Skip this commission
          }

          const month = date.getMonth() + 1;
          const year = date.getFullYear();
          const key = `${year}-${month}`;

          if (!monthlyCommissions[key]) {
            monthlyCommissions[key] = 0;
          }

          // Try different amount fields
          const amount = commission.Amount || commission.amount || commission.Value || commission.value || 0;
          monthlyCommissions[key] += parseFloat(amount || 0);
        });

        return monthlyCommissions;
      }
    };

    const affiliateService = {
      // Dashboard data
      getDashboardData: async function (userId) {
        try {
          // Get affiliate record
          const affiliate = await firebaseService.getAffiliateByUserId(userId);
          if (!affiliate) return null;

          // Try both approaches to calculate commissions
          let commissions = await firebaseService.getCommissionsByAffiliateId(affiliate.affiliateId);

          // Get customers
          const customers = await firebaseService.getCustomersByAffiliateId(affiliate.affiliateId);

          // If we have customers but no commissions, calculate from orders directly like in Commissions page
          if (customers.length > 0 && commissions.length === 0) {
            console.log("No commissions found in collection, calculating from orders directly");
            commissions = await calculateCommissionsFromOrders(affiliate.affiliateId, customers);
          }

          // Calculate summary
          const totalCommission = firebaseService.getTotalCommission(commissions);
          const unpaidCommission = firebaseService.getUnpaidCommission(commissions);
          const paidCommission = totalCommission - unpaidCommission;
          const monthlyCommissions = firebaseService.getCommissionsByMonth(commissions);

          return {
            affiliate,
            commissions: commissions.slice(0, 5), // Most recent 5
            customers: customers.slice(0, 5),     // First 5 customers
            customerCount: customers.length,
            totalCommission,
            unpaidCommission,
            paidCommission,
            monthlyCommissions
          };
        } catch (error) {
          console.error('Error getting dashboard data:', error);
          return null;
        }
      }
    };

    // Helper function to calculate commissions directly from orders
    async function calculateCommissionsFromOrders(affiliateId, customers) {
      try {
        const db = firebase.firestore();
        const calculatedCommissions = [];

        console.log(`Calculating commissions from orders for ${customers.length} customers`);

        for (const customer of customers) {
          const customerId = customer.customerId;

          // Try with PascalCase first
          let orderSnapshot = await db.collection('orders')
            .where('UserId', '==', customerId)
            .get();

          // If no results, try with camelCase
          if (orderSnapshot.empty) {
            orderSnapshot = await db.collection('orders')
              .where('userId', '==', customerId)
              .get();
          }

          console.log(`Found ${orderSnapshot.size} orders for customer ${customerId}`);

          for (const orderDoc of orderSnapshot.docs) {
            const order = orderDoc.data();
            order.orderId = orderDoc.id;

            // Check if order has embedded items
            if (order.items && Array.isArray(order.items) && order.items.length > 0) {
              for (const item of order.items) {
                const productId = item.productId || item.ProductId;
                if (!productId) continue;

                // Get product details
                const productDoc = await db.collection('products').doc(productId).get();
                if (!productDoc.exists) continue;

                const product = productDoc.data();

                // Get commission rate
                let commissionRate = 0;
                if (product.Commission !== undefined) {
                  commissionRate = parseFloat(product.Commission);
                } else if (product.commission !== undefined) {
                  commissionRate = parseFloat(product.commission);
                } else if (product.BrandId || product.brandId) {
                  const brandId = product.BrandId || product.brandId;
                  const brandDoc = await db.collection('brands').doc(brandId).get();
                  if (brandDoc.exists) {
                    const brandData = brandDoc.data();
                    commissionRate = parseFloat(brandData.CommissionRate || 0);
                  }
                }

                // Calculate commission
                const quantity = parseInt(item.quantity || 0);
                const price = parseFloat(item.price || 0);
                const subtotal = price * quantity;
                const commissionAmount = subtotal * (commissionRate / 100);

                if (commissionAmount > 0) {
                  const isPaid = order.Status === 'Completed' || order.Status === 'Delivered' ||
                    order.status === 'Completed' || order.status === 'Delivered';

                  calculatedCommissions.push({
                    OrderId: order.orderId,
                    CustomerId: customerId,
                    AffiliateId: affiliateId,
                    Amount: commissionAmount,
                    IsPaid: isPaid,
                    CreatedAt: order.CreatedAt || order.createdAt || firebase.firestore.Timestamp.now()
                  });
                }
              }
            }
          }
        }

        console.log(`Calculated ${calculatedCommissions.length} commissions from orders`);
        return calculatedCommissions;
      } catch (error) {
        console.error('Error calculating commissions from orders:', error);
        return [];
      }
    }

    // Initialize Firebase
    document.addEventListener('DOMContentLoaded', function () {
      const firebaseConfig = {
        apiKey: "@ViewBag.FirebaseApiKey",
        authDomain: "@ViewBag.FirebaseAuthDomain",
        projectId: "@ViewBag.FirebaseProjectId",
        storageBucket: "@ViewBag.FirebaseStorageBucket",
        messagingSenderId: "@ViewBag.FirebaseMessagingSenderId",
        appId: "@ViewBag.FirebaseAppId"
      };

      // Initialize services
      firebaseService.init(firebaseConfig);

      // Load dashboard data
      loadDashboard();
    });

    async function loadDashboard() {
      try {
        const userId = "@ViewBag.UserId"; // Get from session

        if (!userId) {
          if (typeof Swal !== 'undefined') {
            Swal.fire({
              title: 'Authentication Error',
              text: 'Your session appears to be invalid. Please log in again.',
              icon: 'error'
            });
          }
          console.error('User ID not found in session');
          return;
        }

        // Show loading state
        document.getElementById('dashboard-content').classList.add('loading');

        // Get dashboard data
        const data = await affiliateService.getDashboardData(userId);

        if (!data) {
          if (typeof Swal !== 'undefined') {
            Swal.fire({
              title: 'Data Loading Error',
              text: 'Unable to load affiliate data. Please try again later.',
              icon: 'warning'
            });
          }
          document.getElementById('dashboard-content').innerHTML =
            '<div class="alert alert-danger">Error loading affiliate data. Please try refreshing the page.</div>';
          return;
        }

        // Update UI elements with proper formatting
        document.getElementById('total-earnings').textContent = `$${formatCurrency(data.totalCommission || 0)}`;
        document.getElementById('paid-earnings').textContent = `$${formatCurrency(data.paidCommission || 0)}`;
        document.getElementById('unpaid-earnings').textContent = `$${formatCurrency(data.unpaidCommission || 0)}`;
        document.getElementById('customer-count').textContent = data.customerCount || 0;

        // Populate recent commissions
        const commissionsTable = document.getElementById('recent-commissions');
        const commissionsBody = commissionsTable.querySelector('tbody');
        commissionsBody.innerHTML = '';

        if (data.commissions && data.commissions.length > 0) {
          data.commissions.forEach(commission => {
            const date = commission.CreatedAt?.toDate?.()
              ? commission.CreatedAt.toDate().toLocaleDateString()
              : 'Unknown';
            const row = `
                                <tr>
                                  <td>${commission.OrderId || 'N/A'}</td>
                                  <td>${commission.CustomerId || 'N/A'}</td>
                                  <td>$${formatCurrency(commission.Amount || 0)}</td>
                                  <td>${commission.IsPaid ? 'Paid' : 'Pending'}</td>
                                  <td>${date}</td>
                                </tr>
                              `;
            commissionsBody.innerHTML += row;
          });
        } else {
          commissionsBody.innerHTML = '<tr><td colspan="5" class="text-center">No commission records found</td></tr>';
        }

        // Populate recent customers
        const customersTable = document.getElementById('recent-customers');
        const customersBody = customersTable.querySelector('tbody');
        customersBody.innerHTML = '';

        if (data.customers && data.customers.length > 0) {
          data.customers.forEach(customer => {
            const row = `
                                <tr>
                                  <td>${customer.customerId || 'N/A'}</td>
                                  <td>${(customer.FirstName || '') + ' ' + (customer.LastName || '').trim() || 'Unknown'}</td>
                                  <td>${customer.Email || 'N/A'}</td>
                                </tr>
                              `;
            customersBody.innerHTML += row;
          });
        } else {
          customersBody.innerHTML = '<tr><td colspan="3" class="text-center">No customer records found</td></tr>';
        }

        // Initialize chart with monthly data if Chart.js is available
        if (typeof Chart !== 'undefined' && data.monthlyCommissions) {
          initializeChart(data.monthlyCommissions);
        } else if (typeof Chart === 'undefined') {
          console.warn('Chart.js not loaded');
          document.getElementById('earnings-chart').closest('.card').querySelector('.card-body').innerHTML =
            '<div class="alert alert-warning">Chart library not available</div>';
        }

        console.log("Dashboard data loaded:", {
          totalCommission: data.totalCommission,
          paidCommission: data.paidCommission,
          unpaidCommission: data.unpaidCommission
        });

      } catch (error) {
        console.error('Error loading dashboard:', error);
        if (typeof Swal !== 'undefined') {
          Swal.fire({
            title: 'Error',
            text: 'Failed to load dashboard data: ' + error.message,
            icon: 'error'
          });
        }
        document.getElementById('dashboard-content').innerHTML =
          `<div class="alert alert-danger">Error: ${error.message}</div>`;
      } finally {
        // Remove loading state
        document.getElementById('dashboard-content').classList.remove('loading');
      }
    }

    function initializeChart(monthlyData) {
      try {
        console.log("Initializing chart with data:", monthlyData);

        if (!monthlyData || Object.keys(monthlyData).length === 0) {
          console.log("No monthly data available for chart");
          document.getElementById('earnings-chart').closest('.card').querySelector('.card-body').innerHTML =
            '<div class="alert alert-info">No earnings data available for chart</div>';
          return;
        }

        // Ensure we're displaying months in chronological order
        const sortedKeys = Object.keys(monthlyData).sort();

        const months = sortedKeys.map(key => {
          const [year, month] = key.split('-');
          return new Date(year, month - 1).toLocaleString('default', { month: 'short', year: '2-digit' });
        });

        const values = sortedKeys.map(key => parseFloat(monthlyData[key].toFixed(2)));

        console.log("Chart data prepared:", { months, values });

        const ctx = document.getElementById('earnings-chart').getContext('2d');
        new Chart(ctx, {
          type: 'bar',
          data: {
            labels: months,
            datasets: [{
              label: 'Monthly Commission',
              data: values,
              backgroundColor: 'rgba(54, 162, 235, 0.2)',
              borderColor: 'rgba(54, 162, 235, 1)',
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  callback: function (value) {
                    return '$' + value;
                  }
                }
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  label: function (context) {
                    return '$' + context.parsed.y.toFixed(2);
                  }
                }
              }
            }
          }
        });
      } catch (error) {
        console.error("Error initializing chart:", error);
        document.getElementById('earnings-chart').closest('.card').querySelector('.card-body').innerHTML =
          '<div class="alert alert-danger">Error generating chart: ' + error.message + '</div>';
      }
    }

    // Helper function for formatting currency values
    function formatCurrency(value) {
      if (isNaN(value)) return '0.00';
      return parseFloat(value).toFixed(2).replace(/\d(?=(\d{3})+\.)/g, '$&,');
    }
  </script>
}
